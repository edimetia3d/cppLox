
// clang-format off
// DO NOT EDIT: this file is generated by nodes_code_writer.py at 08/27/2021, 21:47:02
// The file in source tree will only be used when python3 is not found by cmake, and might be out of sync.

#include <memory>
#include <stack>
#include "lox/frontend/token.h"
namespace lox{
class VarDeclStmt;
class WhileStmt;
class ExprStmt;
class FunctionStmt;
class ClassStmt;
class PrintStmt;
class ReturnStmt;
class BlockStmt;
class IfStmt;
class BreakStmt;
class AssignExpr;
class LogicalExpr;
class BinaryExpr;
class GroupingExpr;
class LiteralExpr;
class UnaryExpr;
class CallExpr;
class GetAttrExpr;
class SetAttrExpr;
class VariableExpr;

class IAstNodeVisitor {

protected:

friend class VarDeclStmt;
virtual void Visit(VarDeclStmt *) = 0;

friend class WhileStmt;
virtual void Visit(WhileStmt *) = 0;

friend class ExprStmt;
virtual void Visit(ExprStmt *) = 0;

friend class FunctionStmt;
virtual void Visit(FunctionStmt *) = 0;

friend class ClassStmt;
virtual void Visit(ClassStmt *) = 0;

friend class PrintStmt;
virtual void Visit(PrintStmt *) = 0;

friend class ReturnStmt;
virtual void Visit(ReturnStmt *) = 0;

friend class BlockStmt;
virtual void Visit(BlockStmt *) = 0;

friend class IfStmt;
virtual void Visit(IfStmt *) = 0;

friend class BreakStmt;
virtual void Visit(BreakStmt *) = 0;

friend class AssignExpr;
virtual void Visit(AssignExpr *) = 0;

friend class LogicalExpr;
virtual void Visit(LogicalExpr *) = 0;

friend class BinaryExpr;
virtual void Visit(BinaryExpr *) = 0;

friend class GroupingExpr;
virtual void Visit(GroupingExpr *) = 0;

friend class LiteralExpr;
virtual void Visit(LiteralExpr *) = 0;

friend class UnaryExpr;
virtual void Visit(UnaryExpr *) = 0;

friend class CallExpr;
virtual void Visit(CallExpr *) = 0;

friend class GetAttrExpr;
virtual void Visit(GetAttrExpr *) = 0;

friend class SetAttrExpr;
virtual void Visit(SetAttrExpr *) = 0;

friend class VariableExpr;
virtual void Visit(VariableExpr *) = 0;

};

#define VisitorReturn(arg) _Return(arg);return;
template<class T>
class AstNodeVisitor:public IAstNodeVisitor{
public:
  void _Return(T&& new_ret){
    ret_stk_.push(std::move(new_ret));
  }
  void _Return(const T& new_ret){
    ret_stk_.push(std::move(new_ret));
  }
  T PopRet(){
    auto ret = ret_stk_.top();
    ret_stk_.pop();
    return ret;
  }
protected:
  std::stack<T> ret_stk_;
};





class VarDeclStmt:public StmtBase
{
private:
explicit VarDeclStmt(StmtBase *parent,Token name_in,Expr initializer_in)
:StmtBase(parent),
name_(std::move(name_in)),
initializer_(std::move(initializer_in)){
BindParent(name_,this);
BindParent(initializer_,this);
}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}
void name(Token new_value){
     if(new_value != name_){
        is_modified_ = true;
     }
     name_=new_value;
     BindParent(name_,this);
}


private:
Expr initializer_;
public:
const Expr & initializer(){
    return initializer_;
}
void initializer(Expr new_value){
     if(new_value != initializer_){
        is_modified_ = true;
     }
     initializer_=new_value;
     BindParent(initializer_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(name()) || ::lox::IsModified(initializer());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(name());
::lox::ResetModify(initializer());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class WhileStmt:public StmtBase
{
private:
explicit WhileStmt(StmtBase *parent,Expr condition_in,Stmt body_in)
:StmtBase(parent),
condition_(std::move(condition_in)),
body_(std::move(body_in)){
BindParent(condition_,this);
BindParent(body_,this);
}
friend AstNode;
public:

private:
Expr condition_;
public:
const Expr & condition(){
    return condition_;
}
void condition(Expr new_value){
     if(new_value != condition_){
        is_modified_ = true;
     }
     condition_=new_value;
     BindParent(condition_,this);
}


private:
Stmt body_;
public:
const Stmt & body(){
    return body_;
}
void body(Stmt new_value){
     if(new_value != body_){
        is_modified_ = true;
     }
     body_=new_value;
     BindParent(body_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(condition()) || ::lox::IsModified(body());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(condition());
::lox::ResetModify(body());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class ExprStmt:public StmtBase
{
private:
explicit ExprStmt(StmtBase *parent,Expr expression_in)
:StmtBase(parent),
expression_(std::move(expression_in)){
BindParent(expression_,this);
}
friend AstNode;
public:

private:
Expr expression_;
public:
const Expr & expression(){
    return expression_;
}
void expression(Expr new_value){
     if(new_value != expression_){
        is_modified_ = true;
     }
     expression_=new_value;
     BindParent(expression_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(expression());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(expression());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class FunctionStmt:public StmtBase
{
private:
explicit FunctionStmt(StmtBase *parent,Token name_in,std::vector<Token> params_in,std::vector<Stmt> body_in)
:StmtBase(parent),
name_(std::move(name_in)),
params_(std::move(params_in)),
body_(std::move(body_in)){
BindParent(name_,this);
BindParent(params_,this);
BindParent(body_,this);
}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}
void name(Token new_value){
     if(new_value != name_){
        is_modified_ = true;
     }
     name_=new_value;
     BindParent(name_,this);
}


private:
std::vector<Token> params_;
public:
const std::vector<Token> & params(){
    return params_;
}
void params(std::vector<Token> new_value){
     if(new_value != params_){
        is_modified_ = true;
     }
     params_=new_value;
     BindParent(params_,this);
}


private:
std::vector<Stmt> body_;
public:
const std::vector<Stmt> & body(){
    return body_;
}
void body(std::vector<Stmt> new_value){
     if(new_value != body_){
        is_modified_ = true;
     }
     body_=new_value;
     BindParent(body_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(name()) || ::lox::IsModified(params()) || ::lox::IsModified(body());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(name());
::lox::ResetModify(params());
::lox::ResetModify(body());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class ClassStmt:public StmtBase
{
private:
explicit ClassStmt(StmtBase *parent,Token name_in,Expr superclass_in,std::vector<Stmt> methods_in)
:StmtBase(parent),
name_(std::move(name_in)),
superclass_(std::move(superclass_in)),
methods_(std::move(methods_in)){
BindParent(name_,this);
BindParent(superclass_,this);
BindParent(methods_,this);
}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}
void name(Token new_value){
     if(new_value != name_){
        is_modified_ = true;
     }
     name_=new_value;
     BindParent(name_,this);
}


private:
Expr superclass_;
public:
const Expr & superclass(){
    return superclass_;
}
void superclass(Expr new_value){
     if(new_value != superclass_){
        is_modified_ = true;
     }
     superclass_=new_value;
     BindParent(superclass_,this);
}


private:
std::vector<Stmt> methods_;
public:
const std::vector<Stmt> & methods(){
    return methods_;
}
void methods(std::vector<Stmt> new_value){
     if(new_value != methods_){
        is_modified_ = true;
     }
     methods_=new_value;
     BindParent(methods_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(name()) || ::lox::IsModified(superclass()) || ::lox::IsModified(methods());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(name());
::lox::ResetModify(superclass());
::lox::ResetModify(methods());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class PrintStmt:public StmtBase
{
private:
explicit PrintStmt(StmtBase *parent,Expr expression_in)
:StmtBase(parent),
expression_(std::move(expression_in)){
BindParent(expression_,this);
}
friend AstNode;
public:

private:
Expr expression_;
public:
const Expr & expression(){
    return expression_;
}
void expression(Expr new_value){
     if(new_value != expression_){
        is_modified_ = true;
     }
     expression_=new_value;
     BindParent(expression_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(expression());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(expression());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class ReturnStmt:public StmtBase
{
private:
explicit ReturnStmt(StmtBase *parent,Token keyword_in,Expr value_in)
:StmtBase(parent),
keyword_(std::move(keyword_in)),
value_(std::move(value_in)){
BindParent(keyword_,this);
BindParent(value_,this);
}
friend AstNode;
public:

private:
Token keyword_;
public:
const Token & keyword(){
    return keyword_;
}
void keyword(Token new_value){
     if(new_value != keyword_){
        is_modified_ = true;
     }
     keyword_=new_value;
     BindParent(keyword_,this);
}


private:
Expr value_;
public:
const Expr & value(){
    return value_;
}
void value(Expr new_value){
     if(new_value != value_){
        is_modified_ = true;
     }
     value_=new_value;
     BindParent(value_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(keyword()) || ::lox::IsModified(value());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(keyword());
::lox::ResetModify(value());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class BlockStmt:public StmtBase
{
private:
explicit BlockStmt(StmtBase *parent,std::vector<Stmt> statements_in)
:StmtBase(parent),
statements_(std::move(statements_in)){
BindParent(statements_,this);
}
friend AstNode;
public:

private:
std::vector<Stmt> statements_;
public:
const std::vector<Stmt> & statements(){
    return statements_;
}
void statements(std::vector<Stmt> new_value){
     if(new_value != statements_){
        is_modified_ = true;
     }
     statements_=new_value;
     BindParent(statements_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(statements());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(statements());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class IfStmt:public StmtBase
{
private:
explicit IfStmt(StmtBase *parent,Expr condition_in,Stmt thenBranch_in,Stmt elseBranch_in)
:StmtBase(parent),
condition_(std::move(condition_in)),
thenBranch_(std::move(thenBranch_in)),
elseBranch_(std::move(elseBranch_in)){
BindParent(condition_,this);
BindParent(thenBranch_,this);
BindParent(elseBranch_,this);
}
friend AstNode;
public:

private:
Expr condition_;
public:
const Expr & condition(){
    return condition_;
}
void condition(Expr new_value){
     if(new_value != condition_){
        is_modified_ = true;
     }
     condition_=new_value;
     BindParent(condition_,this);
}


private:
Stmt thenBranch_;
public:
const Stmt & thenBranch(){
    return thenBranch_;
}
void thenBranch(Stmt new_value){
     if(new_value != thenBranch_){
        is_modified_ = true;
     }
     thenBranch_=new_value;
     BindParent(thenBranch_,this);
}


private:
Stmt elseBranch_;
public:
const Stmt & elseBranch(){
    return elseBranch_;
}
void elseBranch(Stmt new_value){
     if(new_value != elseBranch_){
        is_modified_ = true;
     }
     elseBranch_=new_value;
     BindParent(elseBranch_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(condition()) || ::lox::IsModified(thenBranch()) || ::lox::IsModified(elseBranch());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(condition());
::lox::ResetModify(thenBranch());
::lox::ResetModify(elseBranch());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class BreakStmt:public StmtBase
{
private:
explicit BreakStmt(StmtBase *parent,Token src_token_in)
:StmtBase(parent),
src_token_(std::move(src_token_in)){
BindParent(src_token_,this);
}
friend AstNode;
public:

private:
Token src_token_;
public:
const Token & src_token(){
    return src_token_;
}
void src_token(Token new_value){
     if(new_value != src_token_){
        is_modified_ = true;
     }
     src_token_=new_value;
     BindParent(src_token_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(src_token());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(src_token());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class AssignExpr:public ExprBase
{
private:
explicit AssignExpr(ExprBase *parent,Token name_in,Expr value_in)
:ExprBase(parent),
name_(std::move(name_in)),
value_(std::move(value_in)){
BindParent(name_,this);
BindParent(value_,this);
}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}
void name(Token new_value){
     if(new_value != name_){
        is_modified_ = true;
     }
     name_=new_value;
     BindParent(name_,this);
}


private:
Expr value_;
public:
const Expr & value(){
    return value_;
}
void value(Expr new_value){
     if(new_value != value_){
        is_modified_ = true;
     }
     value_=new_value;
     BindParent(value_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(name()) || ::lox::IsModified(value());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(name());
::lox::ResetModify(value());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class LogicalExpr:public ExprBase
{
private:
explicit LogicalExpr(ExprBase *parent,Expr left_in,Token op_in,Expr right_in)
:ExprBase(parent),
left_(std::move(left_in)),
op_(std::move(op_in)),
right_(std::move(right_in)){
BindParent(left_,this);
BindParent(op_,this);
BindParent(right_,this);
}
friend AstNode;
public:

private:
Expr left_;
public:
const Expr & left(){
    return left_;
}
void left(Expr new_value){
     if(new_value != left_){
        is_modified_ = true;
     }
     left_=new_value;
     BindParent(left_,this);
}


private:
Token op_;
public:
const Token & op(){
    return op_;
}
void op(Token new_value){
     if(new_value != op_){
        is_modified_ = true;
     }
     op_=new_value;
     BindParent(op_,this);
}


private:
Expr right_;
public:
const Expr & right(){
    return right_;
}
void right(Expr new_value){
     if(new_value != right_){
        is_modified_ = true;
     }
     right_=new_value;
     BindParent(right_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(left()) || ::lox::IsModified(op()) || ::lox::IsModified(right());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(left());
::lox::ResetModify(op());
::lox::ResetModify(right());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class BinaryExpr:public ExprBase
{
private:
explicit BinaryExpr(ExprBase *parent,Expr left_in,Token op_in,Expr right_in)
:ExprBase(parent),
left_(std::move(left_in)),
op_(std::move(op_in)),
right_(std::move(right_in)){
BindParent(left_,this);
BindParent(op_,this);
BindParent(right_,this);
}
friend AstNode;
public:

private:
Expr left_;
public:
const Expr & left(){
    return left_;
}
void left(Expr new_value){
     if(new_value != left_){
        is_modified_ = true;
     }
     left_=new_value;
     BindParent(left_,this);
}


private:
Token op_;
public:
const Token & op(){
    return op_;
}
void op(Token new_value){
     if(new_value != op_){
        is_modified_ = true;
     }
     op_=new_value;
     BindParent(op_,this);
}


private:
Expr right_;
public:
const Expr & right(){
    return right_;
}
void right(Expr new_value){
     if(new_value != right_){
        is_modified_ = true;
     }
     right_=new_value;
     BindParent(right_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(left()) || ::lox::IsModified(op()) || ::lox::IsModified(right());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(left());
::lox::ResetModify(op());
::lox::ResetModify(right());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class GroupingExpr:public ExprBase
{
private:
explicit GroupingExpr(ExprBase *parent,Expr expression_in)
:ExprBase(parent),
expression_(std::move(expression_in)){
BindParent(expression_,this);
}
friend AstNode;
public:

private:
Expr expression_;
public:
const Expr & expression(){
    return expression_;
}
void expression(Expr new_value){
     if(new_value != expression_){
        is_modified_ = true;
     }
     expression_=new_value;
     BindParent(expression_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(expression());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(expression());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class LiteralExpr:public ExprBase
{
private:
explicit LiteralExpr(ExprBase *parent,Token value_in)
:ExprBase(parent),
value_(std::move(value_in)){
BindParent(value_,this);
}
friend AstNode;
public:

private:
Token value_;
public:
const Token & value(){
    return value_;
}
void value(Token new_value){
     if(new_value != value_){
        is_modified_ = true;
     }
     value_=new_value;
     BindParent(value_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(value());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(value());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class UnaryExpr:public ExprBase
{
private:
explicit UnaryExpr(ExprBase *parent,Token op_in,Expr right_in)
:ExprBase(parent),
op_(std::move(op_in)),
right_(std::move(right_in)){
BindParent(op_,this);
BindParent(right_,this);
}
friend AstNode;
public:

private:
Token op_;
public:
const Token & op(){
    return op_;
}
void op(Token new_value){
     if(new_value != op_){
        is_modified_ = true;
     }
     op_=new_value;
     BindParent(op_,this);
}


private:
Expr right_;
public:
const Expr & right(){
    return right_;
}
void right(Expr new_value){
     if(new_value != right_){
        is_modified_ = true;
     }
     right_=new_value;
     BindParent(right_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(op()) || ::lox::IsModified(right());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(op());
::lox::ResetModify(right());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class CallExpr:public ExprBase
{
private:
explicit CallExpr(ExprBase *parent,Expr callee_in,Token paren_in,std::vector<Expr> arguments_in)
:ExprBase(parent),
callee_(std::move(callee_in)),
paren_(std::move(paren_in)),
arguments_(std::move(arguments_in)){
BindParent(callee_,this);
BindParent(paren_,this);
BindParent(arguments_,this);
}
friend AstNode;
public:

private:
Expr callee_;
public:
const Expr & callee(){
    return callee_;
}
void callee(Expr new_value){
     if(new_value != callee_){
        is_modified_ = true;
     }
     callee_=new_value;
     BindParent(callee_,this);
}


private:
Token paren_;
public:
const Token & paren(){
    return paren_;
}
void paren(Token new_value){
     if(new_value != paren_){
        is_modified_ = true;
     }
     paren_=new_value;
     BindParent(paren_,this);
}


private:
std::vector<Expr> arguments_;
public:
const std::vector<Expr> & arguments(){
    return arguments_;
}
void arguments(std::vector<Expr> new_value){
     if(new_value != arguments_){
        is_modified_ = true;
     }
     arguments_=new_value;
     BindParent(arguments_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(callee()) || ::lox::IsModified(paren()) || ::lox::IsModified(arguments());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(callee());
::lox::ResetModify(paren());
::lox::ResetModify(arguments());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class GetAttrExpr:public ExprBase
{
private:
explicit GetAttrExpr(ExprBase *parent,Expr src_object_in,Token attr_name_in)
:ExprBase(parent),
src_object_(std::move(src_object_in)),
attr_name_(std::move(attr_name_in)){
BindParent(src_object_,this);
BindParent(attr_name_,this);
}
friend AstNode;
public:

private:
Expr src_object_;
public:
const Expr & src_object(){
    return src_object_;
}
void src_object(Expr new_value){
     if(new_value != src_object_){
        is_modified_ = true;
     }
     src_object_=new_value;
     BindParent(src_object_,this);
}


private:
Token attr_name_;
public:
const Token & attr_name(){
    return attr_name_;
}
void attr_name(Token new_value){
     if(new_value != attr_name_){
        is_modified_ = true;
     }
     attr_name_=new_value;
     BindParent(attr_name_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(src_object()) || ::lox::IsModified(attr_name());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(src_object());
::lox::ResetModify(attr_name());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class SetAttrExpr:public ExprBase
{
private:
explicit SetAttrExpr(ExprBase *parent,Expr src_object_in,Token attr_name_in,Expr value_in)
:ExprBase(parent),
src_object_(std::move(src_object_in)),
attr_name_(std::move(attr_name_in)),
value_(std::move(value_in)){
BindParent(src_object_,this);
BindParent(attr_name_,this);
BindParent(value_,this);
}
friend AstNode;
public:

private:
Expr src_object_;
public:
const Expr & src_object(){
    return src_object_;
}
void src_object(Expr new_value){
     if(new_value != src_object_){
        is_modified_ = true;
     }
     src_object_=new_value;
     BindParent(src_object_,this);
}


private:
Token attr_name_;
public:
const Token & attr_name(){
    return attr_name_;
}
void attr_name(Token new_value){
     if(new_value != attr_name_){
        is_modified_ = true;
     }
     attr_name_=new_value;
     BindParent(attr_name_,this);
}


private:
Expr value_;
public:
const Expr & value(){
    return value_;
}
void value(Expr new_value){
     if(new_value != value_){
        is_modified_ = true;
     }
     value_=new_value;
     BindParent(value_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(src_object()) || ::lox::IsModified(attr_name()) || ::lox::IsModified(value());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(src_object());
::lox::ResetModify(attr_name());
::lox::ResetModify(value());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class VariableExpr:public ExprBase
{
private:
explicit VariableExpr(ExprBase *parent,Token name_in)
:ExprBase(parent),
name_(std::move(name_in)){
BindParent(name_,this);
}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}
void name(Token new_value){
     if(new_value != name_){
        is_modified_ = true;
     }
     name_=new_value;
     BindParent(name_,this);
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(name());
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(name());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};


} // namespace lox
// clang-format on
