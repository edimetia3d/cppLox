
// clang-format off
// DO NOT EDIT: this file is generated by nodes_code_writer.py at 08/22/2021, 14:19:26
// The file in source tree will only be used when python3 is not found by cmake, and might be out of sync.

#include "lox/lox_object/lox_object.h"
#include "lox/token.h"
namespace lox{
class VarDeclStmt;
class WhileStmt;
class ExprStmt;
class FunctionStmt;
class ClassStmt;
class PrintStmt;
class ReturnStmt;
class BlockStmt;
class IfStmt;
class BreakStmt;

class StmtVisitor {

protected:

friend class VarDeclStmt;
virtual object::LoxObject Visit(VarDeclStmt *) = 0;

friend class WhileStmt;
virtual object::LoxObject Visit(WhileStmt *) = 0;

friend class ExprStmt;
virtual object::LoxObject Visit(ExprStmt *) = 0;

friend class FunctionStmt;
virtual object::LoxObject Visit(FunctionStmt *) = 0;

friend class ClassStmt;
virtual object::LoxObject Visit(ClassStmt *) = 0;

friend class PrintStmt;
virtual object::LoxObject Visit(PrintStmt *) = 0;

friend class ReturnStmt;
virtual object::LoxObject Visit(ReturnStmt *) = 0;

friend class BlockStmt;
virtual object::LoxObject Visit(BlockStmt *) = 0;

friend class IfStmt;
virtual object::LoxObject Visit(IfStmt *) = 0;

friend class BreakStmt;
virtual object::LoxObject Visit(BreakStmt *) = 0;

};




class VarDeclStmt:public StmtBase
{
private:
explicit VarDeclStmt(StmtBase *parent,Token name_in,Expr initializer_in)
:StmtBase(parent),
name(std::move(name_in)),
initializer(std::move(initializer_in)){
BindParent(name,this);
BindParent(initializer,this);
}
friend AstNode;
public:
Token name;
Expr initializer;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class WhileStmt:public StmtBase
{
private:
explicit WhileStmt(StmtBase *parent,Expr condition_in,Stmt body_in)
:StmtBase(parent),
condition(std::move(condition_in)),
body(std::move(body_in)){
BindParent(condition,this);
BindParent(body,this);
}
friend AstNode;
public:
Expr condition;
Stmt body;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class ExprStmt:public StmtBase
{
private:
explicit ExprStmt(StmtBase *parent,Expr expression_in)
:StmtBase(parent),
expression(std::move(expression_in)){
BindParent(expression,this);
}
friend AstNode;
public:
Expr expression;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class FunctionStmt:public StmtBase
{
private:
explicit FunctionStmt(StmtBase *parent,Token name_in,std::vector<Token> params_in,std::vector<Stmt> body_in)
:StmtBase(parent),
name(std::move(name_in)),
params(std::move(params_in)),
body(std::move(body_in)){
BindParent(name,this);
BindParent(params,this);
BindParent(body,this);
}
friend AstNode;
public:
Token name;
std::vector<Token> params;
std::vector<Stmt> body;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class ClassStmt:public StmtBase
{
private:
explicit ClassStmt(StmtBase *parent,Token name_in,Expr superclass_in,std::vector<Stmt> methods_in)
:StmtBase(parent),
name(std::move(name_in)),
superclass(std::move(superclass_in)),
methods(std::move(methods_in)){
BindParent(name,this);
BindParent(superclass,this);
BindParent(methods,this);
}
friend AstNode;
public:
Token name;
Expr superclass;
std::vector<Stmt> methods;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class PrintStmt:public StmtBase
{
private:
explicit PrintStmt(StmtBase *parent,Expr expression_in)
:StmtBase(parent),
expression(std::move(expression_in)){
BindParent(expression,this);
}
friend AstNode;
public:
Expr expression;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class ReturnStmt:public StmtBase
{
private:
explicit ReturnStmt(StmtBase *parent,Token keyword_in,Expr value_in)
:StmtBase(parent),
keyword(std::move(keyword_in)),
value(std::move(value_in)){
BindParent(keyword,this);
BindParent(value,this);
}
friend AstNode;
public:
Token keyword;
Expr value;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class BlockStmt:public StmtBase
{
private:
explicit BlockStmt(StmtBase *parent,std::vector<Stmt> statements_in)
:StmtBase(parent),
statements(std::move(statements_in)){
BindParent(statements,this);
}
friend AstNode;
public:
std::vector<Stmt> statements;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class IfStmt:public StmtBase
{
private:
explicit IfStmt(StmtBase *parent,Expr condition_in,Stmt thenBranch_in,Stmt elseBranch_in)
:StmtBase(parent),
condition(std::move(condition_in)),
thenBranch(std::move(thenBranch_in)),
elseBranch(std::move(elseBranch_in)){
BindParent(condition,this);
BindParent(thenBranch,this);
BindParent(elseBranch,this);
}
friend AstNode;
public:
Expr condition;
Stmt thenBranch;
Stmt elseBranch;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class BreakStmt:public StmtBase
{
private:
explicit BreakStmt(StmtBase *parent,Token src_token_in)
:StmtBase(parent),
src_token(std::move(src_token_in)){
BindParent(src_token,this);
}
friend AstNode;
public:
Token src_token;

object::LoxObject Accept(StmtVisitor * visitor) override {
  return visitor->Visit(this);
}
};


} // namespace lox
// clang-format on
