
// clang-format off
// DO NOT EDIT: this file is generated by nodes_code_writer.py at 07/25/2021, 22:27:10
// The file in source tree will only be used when python3 is not found by cmake, and might be out of sync.

namespace lox{
class ExprImpl;
class Token;
template<class RetT>
class Visitor;


class Binary:public ExprImpl
{
public:
Binary(Expr left,Token op,Expr right)
:left(left),
op(op),
right(right){}
Expr left;
Token op;
Expr right;


template <class RetT>
RetT _Accept(const Visitor<RetT>& visitor){
  return visitor.VisitBinary(this);
}

template <class RetT>
RetT _Accept(const Visitor<RetT>& visitor) const {
  return visitor.VisitBinary(*this);
}
  
};

class Grouping:public ExprImpl
{
public:
Grouping(Expr expression)
:expression(expression){}
Expr expression;


template <class RetT>
RetT _Accept(const Visitor<RetT>& visitor){
  return visitor.VisitGrouping(this);
}

template <class RetT>
RetT _Accept(const Visitor<RetT>& visitor) const {
  return visitor.VisitGrouping(*this);
}
  
};

class Literal:public ExprImpl
{
public:
Literal(Token value)
:value(value){}
Token value;


template <class RetT>
RetT _Accept(const Visitor<RetT>& visitor){
  return visitor.VisitLiteral(this);
}

template <class RetT>
RetT _Accept(const Visitor<RetT>& visitor) const {
  return visitor.VisitLiteral(*this);
}
  
};

class Unary:public ExprImpl
{
public:
Unary(Token op,Expr right)
:op(op),
right(right){}
Token op;
Expr right;


template <class RetT>
RetT _Accept(const Visitor<RetT>& visitor){
  return visitor.VisitUnary(this);
}

template <class RetT>
RetT _Accept(const Visitor<RetT>& visitor) const {
  return visitor.VisitUnary(*this);
}
  
};


template <class RetT>
class Visitor {
protected:

friend class Binary;
virtual RetT VisitBinary(Binary &) const{
throw "No Impl";
};
virtual RetT VisitBinary(const Binary &) const{
throw "No Impl";
}
friend class Grouping;
virtual RetT VisitGrouping(Grouping &) const{
throw "No Impl";
};
virtual RetT VisitGrouping(const Grouping &) const{
throw "No Impl";
}
friend class Literal;
virtual RetT VisitLiteral(Literal &) const{
throw "No Impl";
};
virtual RetT VisitLiteral(const Literal &) const{
throw "No Impl";
}
friend class Unary;
virtual RetT VisitUnary(Unary &) const{
throw "No Impl";
};
virtual RetT VisitUnary(const Unary &) const{
throw "No Impl";
}
};

template <class RetT>
RetT ExprImpl::Accept(const Visitor<RetT>& v) {
if(auto p = dynamic_cast<Binary *>(this)){return p->_Accept(v);}
if(auto p = dynamic_cast<Grouping *>(this)){return p->_Accept(v);}
if(auto p = dynamic_cast<Literal *>(this)){return p->_Accept(v);}
if(auto p = dynamic_cast<Unary *>(this)){return p->_Accept(v);}

throw "Dispatch Fail";
}

template <class RetT>
RetT ExprImpl::Accept(const Visitor<RetT>& v) const {
if(auto p = dynamic_cast<const Binary *>(this)){return p->_Accept(v);}
if(auto p = dynamic_cast<const Grouping *>(this)){return p->_Accept(v);}
if(auto p = dynamic_cast<const Literal *>(this)){return p->_Accept(v);}
if(auto p = dynamic_cast<const Unary *>(this)){return p->_Accept(v);}

throw "Dispatch Fail";
}

} // namespace lox
// clang-format on
