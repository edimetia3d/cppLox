
// clang-format off
// DO NOT EDIT: this file is generated by nodes_code_writer.py at 02/05/2022, 19:27:04
// The file in source tree will only be used when python3 is not found by cmake, and might be out of sync.
#ifndef LOX_AST_AST_NODE_DECL_H_INC
#define LOX_AST_AST_NODE_DECL_H_INC
#include <memory>
#include "lox/token/token.h"
#include "lox/ast/ast_node.h"

namespace lox{
class AssignExpr;
class LogicalExpr;
class BinaryExpr;
class GroupingExpr;
class LiteralExpr;
class UnaryExpr;
class CallExpr;
class GetAttrExpr;
class SetAttrExpr;
class VariableExpr;
class CommaExpr;
class ListExpr;
class GetItemExpr;
class TensorExpr;
class VarDeclStmt;
class WhileStmt;
class ForStmt;
class ExprStmt;
class FunctionStmt;
class ClassStmt;
class PrintStmt;
class ReturnStmt;
class BlockStmt;
class IfStmt;
class BreakStmt;

class IASTNodeVisitor {

protected:

friend class AssignExpr;
virtual void Visit(AssignExpr *) = 0;

friend class LogicalExpr;
virtual void Visit(LogicalExpr *) = 0;

friend class BinaryExpr;
virtual void Visit(BinaryExpr *) = 0;

friend class GroupingExpr;
virtual void Visit(GroupingExpr *) = 0;

friend class LiteralExpr;
virtual void Visit(LiteralExpr *) = 0;

friend class UnaryExpr;
virtual void Visit(UnaryExpr *) = 0;

friend class CallExpr;
virtual void Visit(CallExpr *) = 0;

friend class GetAttrExpr;
virtual void Visit(GetAttrExpr *) = 0;

friend class SetAttrExpr;
virtual void Visit(SetAttrExpr *) = 0;

friend class VariableExpr;
virtual void Visit(VariableExpr *) = 0;

friend class CommaExpr;
virtual void Visit(CommaExpr *) = 0;

friend class ListExpr;
virtual void Visit(ListExpr *) = 0;

friend class GetItemExpr;
virtual void Visit(GetItemExpr *) = 0;

friend class TensorExpr;
virtual void Visit(TensorExpr *) = 0;

friend class VarDeclStmt;
virtual void Visit(VarDeclStmt *) = 0;

friend class WhileStmt;
virtual void Visit(WhileStmt *) = 0;

friend class ForStmt;
virtual void Visit(ForStmt *) = 0;

friend class ExprStmt;
virtual void Visit(ExprStmt *) = 0;

friend class FunctionStmt;
virtual void Visit(FunctionStmt *) = 0;

friend class ClassStmt;
virtual void Visit(ClassStmt *) = 0;

friend class PrintStmt;
virtual void Visit(PrintStmt *) = 0;

friend class ReturnStmt;
virtual void Visit(ReturnStmt *) = 0;

friend class BlockStmt;
virtual void Visit(BlockStmt *) = 0;

friend class IfStmt;
virtual void Visit(IfStmt *) = 0;

friend class BreakStmt;
virtual void Visit(BreakStmt *) = 0;

};


struct AssignExprAttr: public ASTNodeAttr{
Token name;
};

class AssignExpr:public Expr {
public:
AssignExpr(const AssignExprAttr & attr_,ExprPtr&& value_):attr(std::make_unique<AssignExprAttr>(attr_)),value(std::move(value_)){
AddChild(&value);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<AssignExprAttr> attr;
ExprPtr value;
};


struct LogicalExprAttr: public ASTNodeAttr{
Token op;
};

class LogicalExpr:public Expr {
public:
LogicalExpr(const LogicalExprAttr & attr_,ExprPtr&& left_,ExprPtr&& right_):attr(std::make_unique<LogicalExprAttr>(attr_)),left(std::move(left_)),right(std::move(right_)){
AddChild(&left);
AddChild(&right);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<LogicalExprAttr> attr;
ExprPtr left;
ExprPtr right;
};


struct BinaryExprAttr: public ASTNodeAttr{
Token op;
};

class BinaryExpr:public Expr {
public:
BinaryExpr(const BinaryExprAttr & attr_,ExprPtr&& left_,ExprPtr&& right_):attr(std::make_unique<BinaryExprAttr>(attr_)),left(std::move(left_)),right(std::move(right_)){
AddChild(&left);
AddChild(&right);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<BinaryExprAttr> attr;
ExprPtr left;
ExprPtr right;
};


struct GroupingExprAttr: public ASTNodeAttr{

};

class GroupingExpr:public Expr {
public:
GroupingExpr(const GroupingExprAttr & attr_,ExprPtr&& expression_):attr(std::make_unique<GroupingExprAttr>(attr_)),expression(std::move(expression_)){
AddChild(&expression);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<GroupingExprAttr> attr;
ExprPtr expression;
};


struct LiteralExprAttr: public ASTNodeAttr{
Token value;
};

class LiteralExpr:public Expr {
public:
LiteralExpr(const LiteralExprAttr & attr_):attr(std::make_unique<LiteralExprAttr>(attr_)){

}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<LiteralExprAttr> attr;

};


struct UnaryExprAttr: public ASTNodeAttr{
Token op;
};

class UnaryExpr:public Expr {
public:
UnaryExpr(const UnaryExprAttr & attr_,ExprPtr&& right_):attr(std::make_unique<UnaryExprAttr>(attr_)),right(std::move(right_)){
AddChild(&right);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<UnaryExprAttr> attr;
ExprPtr right;
};


struct CallExprAttr: public ASTNodeAttr{
Token src_token;
};

class CallExpr:public Expr {
public:
CallExpr(const CallExprAttr & attr_,ExprPtr&& callee_,ExprPtr&& comma_expr_args_):attr(std::make_unique<CallExprAttr>(attr_)),callee(std::move(callee_)),comma_expr_args(std::move(comma_expr_args_)){
AddChild(&callee);
AddChild(&comma_expr_args);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<CallExprAttr> attr;
ExprPtr callee;
ExprPtr comma_expr_args;
};


struct GetAttrExprAttr: public ASTNodeAttr{
Token attr_name;
};

class GetAttrExpr:public Expr {
public:
GetAttrExpr(const GetAttrExprAttr & attr_,ExprPtr&& src_object_):attr(std::make_unique<GetAttrExprAttr>(attr_)),src_object(std::move(src_object_)){
AddChild(&src_object);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<GetAttrExprAttr> attr;
ExprPtr src_object;
};


struct SetAttrExprAttr: public ASTNodeAttr{
Token attr_name;
};

class SetAttrExpr:public Expr {
public:
SetAttrExpr(const SetAttrExprAttr & attr_,ExprPtr&& src_object_,ExprPtr&& value_):attr(std::make_unique<SetAttrExprAttr>(attr_)),src_object(std::move(src_object_)),value(std::move(value_)){
AddChild(&src_object);
AddChild(&value);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<SetAttrExprAttr> attr;
ExprPtr src_object;
ExprPtr value;
};


struct VariableExprAttr: public ASTNodeAttr{
Token name;
};

class VariableExpr:public Expr {
public:
VariableExpr(const VariableExprAttr & attr_):attr(std::make_unique<VariableExprAttr>(attr_)){

}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<VariableExprAttr> attr;

};


struct CommaExprAttr: public ASTNodeAttr{
Token src_token;
};

class CommaExpr:public Expr {
public:
CommaExpr(const CommaExprAttr & attr_,std::vector<ExprPtr>&& elements_):attr(std::make_unique<CommaExprAttr>(attr_)),elements(std::move(elements_)){
AddChild(&elements);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<CommaExprAttr> attr;
std::vector<ExprPtr> elements;
};


struct ListExprAttr: public ASTNodeAttr{
Token src_token;
};

class ListExpr:public Expr {
public:
ListExpr(const ListExprAttr & attr_,ExprPtr&& comma_expr_):attr(std::make_unique<ListExprAttr>(attr_)),comma_expr(std::move(comma_expr_)){
AddChild(&comma_expr);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<ListExprAttr> attr;
ExprPtr comma_expr;
};


struct GetItemExprAttr: public ASTNodeAttr{
Token src_token;
};

class GetItemExpr:public Expr {
public:
GetItemExpr(const GetItemExprAttr & attr_,ExprPtr&& src_object_,ExprPtr&& index_):attr(std::make_unique<GetItemExprAttr>(attr_)),src_object(std::move(src_object_)),index(std::move(index_)){
AddChild(&src_object);
AddChild(&index);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<GetItemExprAttr> attr;
ExprPtr src_object;
ExprPtr index;
};


struct TensorExprAttr: public ASTNodeAttr{
Token src_token;
};

class TensorExpr:public Expr {
public:
TensorExpr(const TensorExprAttr & attr_,ExprPtr&& dtype_,ExprPtr&& shape_,ExprPtr&& data_):attr(std::make_unique<TensorExprAttr>(attr_)),dtype(std::move(dtype_)),shape(std::move(shape_)),data(std::move(data_)){
AddChild(&dtype);
AddChild(&shape);
AddChild(&data);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<TensorExprAttr> attr;
ExprPtr dtype;
ExprPtr shape;
ExprPtr data;
};


struct VarDeclStmtAttr: public ASTNodeAttr{
Token name;
};

class VarDeclStmt:public Stmt {
public:
VarDeclStmt(const VarDeclStmtAttr & attr_,ExprPtr&& initializer_):attr(std::make_unique<VarDeclStmtAttr>(attr_)),initializer(std::move(initializer_)){
AddChild(&initializer);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<VarDeclStmtAttr> attr;
ExprPtr initializer;
};


struct WhileStmtAttr: public ASTNodeAttr{
Token src_token;
};

class WhileStmt:public Stmt {
public:
WhileStmt(const WhileStmtAttr & attr_,ExprPtr&& condition_,StmtPtr&& body_):attr(std::make_unique<WhileStmtAttr>(attr_)),condition(std::move(condition_)),body(std::move(body_)){
AddChild(&condition);
AddChild(&body);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<WhileStmtAttr> attr;
ExprPtr condition;
StmtPtr body;
};


struct ForStmtAttr: public ASTNodeAttr{
Token src_token;
};

class ForStmt:public Stmt {
public:
ForStmt(const ForStmtAttr & attr_,StmtPtr&& initializer_,ExprPtr&& condition_,ExprPtr&& increment_,StmtPtr&& body_):attr(std::make_unique<ForStmtAttr>(attr_)),initializer(std::move(initializer_)),condition(std::move(condition_)),increment(std::move(increment_)),body(std::move(body_)){
AddChild(&initializer);
AddChild(&condition);
AddChild(&increment);
AddChild(&body);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<ForStmtAttr> attr;
StmtPtr initializer;
ExprPtr condition;
ExprPtr increment;
StmtPtr body;
};


struct ExprStmtAttr: public ASTNodeAttr{

};

class ExprStmt:public Stmt {
public:
ExprStmt(const ExprStmtAttr & attr_,ExprPtr&& expression_):attr(std::make_unique<ExprStmtAttr>(attr_)),expression(std::move(expression_)){
AddChild(&expression);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<ExprStmtAttr> attr;
ExprPtr expression;
};


struct FunctionStmtAttr: public ASTNodeAttr{
Token name;
};

class FunctionStmt:public Stmt {
public:
FunctionStmt(const FunctionStmtAttr & attr_,ExprPtr&& comma_expr_params_,std::vector<StmtPtr>&& body_):attr(std::make_unique<FunctionStmtAttr>(attr_)),comma_expr_params(std::move(comma_expr_params_)),body(std::move(body_)){
AddChild(&comma_expr_params);
AddChild(&body);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<FunctionStmtAttr> attr;
ExprPtr comma_expr_params;
std::vector<StmtPtr> body;
};


struct ClassStmtAttr: public ASTNodeAttr{
Token name;
};

class ClassStmt:public Stmt {
public:
ClassStmt(const ClassStmtAttr & attr_,ExprPtr&& superclass_,std::vector<StmtPtr>&& methods_):attr(std::make_unique<ClassStmtAttr>(attr_)),superclass(std::move(superclass_)),methods(std::move(methods_)){
AddChild(&superclass);
AddChild(&methods);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<ClassStmtAttr> attr;
ExprPtr superclass;
std::vector<StmtPtr> methods;
};


struct PrintStmtAttr: public ASTNodeAttr{

};

class PrintStmt:public Stmt {
public:
PrintStmt(const PrintStmtAttr & attr_,ExprPtr&& expression_):attr(std::make_unique<PrintStmtAttr>(attr_)),expression(std::move(expression_)){
AddChild(&expression);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<PrintStmtAttr> attr;
ExprPtr expression;
};


struct ReturnStmtAttr: public ASTNodeAttr{
Token src_token;
};

class ReturnStmt:public Stmt {
public:
ReturnStmt(const ReturnStmtAttr & attr_,ExprPtr&& value_):attr(std::make_unique<ReturnStmtAttr>(attr_)),value(std::move(value_)){
AddChild(&value);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<ReturnStmtAttr> attr;
ExprPtr value;
};


struct BlockStmtAttr: public ASTNodeAttr{

};

class BlockStmt:public Stmt {
public:
BlockStmt(const BlockStmtAttr & attr_,std::vector<StmtPtr>&& statements_):attr(std::make_unique<BlockStmtAttr>(attr_)),statements(std::move(statements_)){
AddChild(&statements);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<BlockStmtAttr> attr;
std::vector<StmtPtr> statements;
};


struct IfStmtAttr: public ASTNodeAttr{

};

class IfStmt:public Stmt {
public:
IfStmt(const IfStmtAttr & attr_,ExprPtr&& condition_,StmtPtr&& then_branch_,StmtPtr&& else_branch_):attr(std::make_unique<IfStmtAttr>(attr_)),condition(std::move(condition_)),then_branch(std::move(then_branch_)),else_branch(std::move(else_branch_)){
AddChild(&condition);
AddChild(&then_branch);
AddChild(&else_branch);
}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<IfStmtAttr> attr;
ExprPtr condition;
StmtPtr then_branch;
StmtPtr else_branch;
};


struct BreakStmtAttr: public ASTNodeAttr{
Token src_token;
};

class BreakStmt:public Stmt {
public:
BreakStmt(const BreakStmtAttr & attr_):attr(std::make_unique<BreakStmtAttr>(attr_)){

}

void Accept(IASTNodeVisitor *visitor) override {
    visitor->Visit(this);
}

std::unique_ptr<BreakStmtAttr> attr;

};



} // namespace lox

#endif // LOX_AST_AST_NODE_DECL_H_INC
// clang-format on
