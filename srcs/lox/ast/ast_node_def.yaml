Expr:
  Assign: { attr: "Token name",child: "ExprPtr value" }
  Logical: { attr: "Token op", child: [ "ExprPtr left","ExprPtr right" ] }
  Binary: { attr: "Token op",child: [ "ExprPtr left","ExprPtr right" ] }
  Grouping: { child: "ExprPtr expression" }
  Literal: { attr: "Token value" }
  Unary: { attr: "Token op",child: "ExprPtr right" }
  Call: { attr: "Token position_in_src",child: [ "ExprPtr callee", "std::vector<ExprPtr> arguments" ] }
  GetAttr: { attr: "Token attr_name",child: "ExprPtr src_object" }
  SetAttr: { attr: "Token attr_name",child: [ "ExprPtr src_object","ExprPtr value" ] }
  Variable: { attr: "Token name" }

Stmt:
  VarDecl: { attr: "Token name",child: "ExprPtr initializer" }
  While: { child: [ "ExprPtr condition", "StmtPtr body" ] }
  For: { child: [ "StmtPtr initializer", "ExprPtr condition","ExprPtr increment", "StmtPtr body" ] }
  Expr: { child: "ExprPtr expression" }
  Function: { attr: [ "Token name","std::vector<Token> params" ],child: [ "std::vector<StmtPtr> body" ] }
  Class: { attr: "Token name", child: [ "ExprPtr superclass", "std::vector<StmtPtr> methods" ] }
  Print: { child: "ExprPtr expression" }
  Return: { attr: "Token keyword", child: "ExprPtr value" }
  Block: { child: "std::vector<StmtPtr> statements" }
  If: { child: [ "ExprPtr condition", "StmtPtr thenBranch", "StmtPtr elseBranch" ] }
  Break: { attr: "Token src_token" }

