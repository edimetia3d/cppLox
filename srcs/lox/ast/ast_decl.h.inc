
// clang-format off
// DO NOT EDIT: this file is generated by nodes_code_writer.py at 08/28/2021, 16:53:32
// The file in source tree will only be used when python3 is not found by cmake, and might be out of sync.

#include <memory>
#include <stack>
#include "lox/token/token.h"
namespace lox{
class VarDeclStmt;
class WhileStmt;
class ExprStmt;
class FunctionStmt;
class ClassStmt;
class PrintStmt;
class ReturnStmt;
class BlockStmt;
class IfStmt;
class BreakStmt;
class AssignExpr;
class LogicalExpr;
class BinaryExpr;
class GroupingExpr;
class LiteralExpr;
class UnaryExpr;
class CallExpr;
class GetAttrExpr;
class SetAttrExpr;
class VariableExpr;

class IAstNodeVisitor {

protected:

friend class VarDeclStmt;
virtual void Visit(VarDeclStmt *) = 0;

friend class WhileStmt;
virtual void Visit(WhileStmt *) = 0;

friend class ExprStmt;
virtual void Visit(ExprStmt *) = 0;

friend class FunctionStmt;
virtual void Visit(FunctionStmt *) = 0;

friend class ClassStmt;
virtual void Visit(ClassStmt *) = 0;

friend class PrintStmt;
virtual void Visit(PrintStmt *) = 0;

friend class ReturnStmt;
virtual void Visit(ReturnStmt *) = 0;

friend class BlockStmt;
virtual void Visit(BlockStmt *) = 0;

friend class IfStmt;
virtual void Visit(IfStmt *) = 0;

friend class BreakStmt;
virtual void Visit(BreakStmt *) = 0;

friend class AssignExpr;
virtual void Visit(AssignExpr *) = 0;

friend class LogicalExpr;
virtual void Visit(LogicalExpr *) = 0;

friend class BinaryExpr;
virtual void Visit(BinaryExpr *) = 0;

friend class GroupingExpr;
virtual void Visit(GroupingExpr *) = 0;

friend class LiteralExpr;
virtual void Visit(LiteralExpr *) = 0;

friend class UnaryExpr;
virtual void Visit(UnaryExpr *) = 0;

friend class CallExpr;
virtual void Visit(CallExpr *) = 0;

friend class GetAttrExpr;
virtual void Visit(GetAttrExpr *) = 0;

friend class SetAttrExpr;
virtual void Visit(SetAttrExpr *) = 0;

friend class VariableExpr;
virtual void Visit(VariableExpr *) = 0;

};

#define VisitorReturn(arg) _Return(arg);return;
template<class T>
class AstNodeVisitor:public IAstNodeVisitor{
public:
  void _Return(T&& new_ret){
    ret_stk_.push(std::move(new_ret));
  }
  void _Return(const T& new_ret){
    ret_stk_.push(std::move(new_ret));
  }
  T PopRet(){
    auto ret = ret_stk_.top();
    ret_stk_.pop();
    return ret;
  }
protected:
  std::stack<T> ret_stk_;
};





class VarDeclStmt:public StmtBase
{
private:
explicit VarDeclStmt(Token name_in,Expr initializer_in)
:name_(std::move(name_in)),
initializer_(std::move(initializer_in)){
UpdateChild(decltype(initializer_)(),initializer_);
}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}


private:
Expr initializer_;
public:
const Expr & initializer(){
    return initializer_;
}


void initializer(Expr new_value){
     if(new_value != initializer_){
        is_modified_ = true;
        UpdateChild(initializer_,new_value);
        initializer_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(initializer());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,initializer());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(initializer());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class WhileStmt:public StmtBase
{
private:
explicit WhileStmt(Expr condition_in,Stmt body_in)
:condition_(std::move(condition_in)),
body_(std::move(body_in)){
UpdateChild(decltype(condition_)(),condition_);
UpdateChild(decltype(body_)(),body_);
}
friend AstNode;
public:

private:
Expr condition_;
public:
const Expr & condition(){
    return condition_;
}


void condition(Expr new_value){
     if(new_value != condition_){
        is_modified_ = true;
        UpdateChild(condition_,new_value);
        condition_=new_value;
     }
}

private:
Stmt body_;
public:
const Stmt & body(){
    return body_;
}


void body(Stmt new_value){
     if(new_value != body_){
        is_modified_ = true;
        UpdateChild(body_,new_value);
        body_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(condition()) || ::lox::IsModified(body());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,condition());
::lox::UpdateSet(return_set,body());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(condition());
::lox::ResetModify(body());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class ExprStmt:public StmtBase
{
private:
explicit ExprStmt(Expr expression_in)
:expression_(std::move(expression_in)){
UpdateChild(decltype(expression_)(),expression_);
}
friend AstNode;
public:

private:
Expr expression_;
public:
const Expr & expression(){
    return expression_;
}


void expression(Expr new_value){
     if(new_value != expression_){
        is_modified_ = true;
        UpdateChild(expression_,new_value);
        expression_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(expression());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,expression());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(expression());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class FunctionStmt:public StmtBase
{
private:
explicit FunctionStmt(Token name_in,std::vector<Token> params_in,std::vector<Stmt> body_in)
:name_(std::move(name_in)),
params_(std::move(params_in)),
body_(std::move(body_in)){
UpdateChild(decltype(body_)(),body_);
}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}


private:
std::vector<Token> params_;
public:
const std::vector<Token> & params(){
    return params_;
}


private:
std::vector<Stmt> body_;
public:
const std::vector<Stmt> & body(){
    return body_;
}


void body(std::vector<Stmt> new_value){
     if(new_value != body_){
        is_modified_ = true;
        UpdateChild(body_,new_value);
        body_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(body());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,body());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(body());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class ClassStmt:public StmtBase
{
private:
explicit ClassStmt(Token name_in,Expr superclass_in,std::vector<Stmt> methods_in)
:name_(std::move(name_in)),
superclass_(std::move(superclass_in)),
methods_(std::move(methods_in)){
UpdateChild(decltype(superclass_)(),superclass_);
UpdateChild(decltype(methods_)(),methods_);
}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}


private:
Expr superclass_;
public:
const Expr & superclass(){
    return superclass_;
}


void superclass(Expr new_value){
     if(new_value != superclass_){
        is_modified_ = true;
        UpdateChild(superclass_,new_value);
        superclass_=new_value;
     }
}

private:
std::vector<Stmt> methods_;
public:
const std::vector<Stmt> & methods(){
    return methods_;
}


void methods(std::vector<Stmt> new_value){
     if(new_value != methods_){
        is_modified_ = true;
        UpdateChild(methods_,new_value);
        methods_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(superclass()) || ::lox::IsModified(methods());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,superclass());
::lox::UpdateSet(return_set,methods());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(superclass());
::lox::ResetModify(methods());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class PrintStmt:public StmtBase
{
private:
explicit PrintStmt(Expr expression_in)
:expression_(std::move(expression_in)){
UpdateChild(decltype(expression_)(),expression_);
}
friend AstNode;
public:

private:
Expr expression_;
public:
const Expr & expression(){
    return expression_;
}


void expression(Expr new_value){
     if(new_value != expression_){
        is_modified_ = true;
        UpdateChild(expression_,new_value);
        expression_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(expression());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,expression());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(expression());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class ReturnStmt:public StmtBase
{
private:
explicit ReturnStmt(Token keyword_in,Expr value_in)
:keyword_(std::move(keyword_in)),
value_(std::move(value_in)){
UpdateChild(decltype(value_)(),value_);
}
friend AstNode;
public:

private:
Token keyword_;
public:
const Token & keyword(){
    return keyword_;
}


private:
Expr value_;
public:
const Expr & value(){
    return value_;
}


void value(Expr new_value){
     if(new_value != value_){
        is_modified_ = true;
        UpdateChild(value_,new_value);
        value_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(value());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,value());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(value());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class BlockStmt:public StmtBase
{
private:
explicit BlockStmt(std::vector<Stmt> statements_in)
:statements_(std::move(statements_in)){
UpdateChild(decltype(statements_)(),statements_);
}
friend AstNode;
public:

private:
std::vector<Stmt> statements_;
public:
const std::vector<Stmt> & statements(){
    return statements_;
}


void statements(std::vector<Stmt> new_value){
     if(new_value != statements_){
        is_modified_ = true;
        UpdateChild(statements_,new_value);
        statements_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(statements());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,statements());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(statements());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class IfStmt:public StmtBase
{
private:
explicit IfStmt(Expr condition_in,Stmt thenBranch_in,Stmt elseBranch_in)
:condition_(std::move(condition_in)),
thenBranch_(std::move(thenBranch_in)),
elseBranch_(std::move(elseBranch_in)){
UpdateChild(decltype(condition_)(),condition_);
UpdateChild(decltype(thenBranch_)(),thenBranch_);
UpdateChild(decltype(elseBranch_)(),elseBranch_);
}
friend AstNode;
public:

private:
Expr condition_;
public:
const Expr & condition(){
    return condition_;
}


void condition(Expr new_value){
     if(new_value != condition_){
        is_modified_ = true;
        UpdateChild(condition_,new_value);
        condition_=new_value;
     }
}

private:
Stmt thenBranch_;
public:
const Stmt & thenBranch(){
    return thenBranch_;
}


void thenBranch(Stmt new_value){
     if(new_value != thenBranch_){
        is_modified_ = true;
        UpdateChild(thenBranch_,new_value);
        thenBranch_=new_value;
     }
}

private:
Stmt elseBranch_;
public:
const Stmt & elseBranch(){
    return elseBranch_;
}


void elseBranch(Stmt new_value){
     if(new_value != elseBranch_){
        is_modified_ = true;
        UpdateChild(elseBranch_,new_value);
        elseBranch_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(condition()) || ::lox::IsModified(thenBranch()) || ::lox::IsModified(elseBranch());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,condition());
::lox::UpdateSet(return_set,thenBranch());
::lox::UpdateSet(return_set,elseBranch());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(condition());
::lox::ResetModify(thenBranch());
::lox::ResetModify(elseBranch());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class BreakStmt:public StmtBase
{
private:
explicit BreakStmt(Token src_token_in)
:src_token_(std::move(src_token_in)){

}
friend AstNode;
public:

private:
Token src_token_;
public:
const Token & src_token(){
    return src_token_;
}


bool IsModified() override{
    return is_modified_;
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ;
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class AssignExpr:public ExprBase
{
private:
explicit AssignExpr(Token name_in,Expr value_in)
:name_(std::move(name_in)),
value_(std::move(value_in)){
UpdateChild(decltype(value_)(),value_);
}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}


private:
Expr value_;
public:
const Expr & value(){
    return value_;
}


void value(Expr new_value){
     if(new_value != value_){
        is_modified_ = true;
        UpdateChild(value_,new_value);
        value_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(value());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,value());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(value());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class LogicalExpr:public ExprBase
{
private:
explicit LogicalExpr(Expr left_in,Token op_in,Expr right_in)
:left_(std::move(left_in)),
op_(std::move(op_in)),
right_(std::move(right_in)){
UpdateChild(decltype(left_)(),left_);
UpdateChild(decltype(right_)(),right_);
}
friend AstNode;
public:

private:
Expr left_;
public:
const Expr & left(){
    return left_;
}


void left(Expr new_value){
     if(new_value != left_){
        is_modified_ = true;
        UpdateChild(left_,new_value);
        left_=new_value;
     }
}

private:
Token op_;
public:
const Token & op(){
    return op_;
}


private:
Expr right_;
public:
const Expr & right(){
    return right_;
}


void right(Expr new_value){
     if(new_value != right_){
        is_modified_ = true;
        UpdateChild(right_,new_value);
        right_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(left()) || ::lox::IsModified(right());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,left());
::lox::UpdateSet(return_set,right());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(left());
::lox::ResetModify(right());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class BinaryExpr:public ExprBase
{
private:
explicit BinaryExpr(Expr left_in,Token op_in,Expr right_in)
:left_(std::move(left_in)),
op_(std::move(op_in)),
right_(std::move(right_in)){
UpdateChild(decltype(left_)(),left_);
UpdateChild(decltype(right_)(),right_);
}
friend AstNode;
public:

private:
Expr left_;
public:
const Expr & left(){
    return left_;
}


void left(Expr new_value){
     if(new_value != left_){
        is_modified_ = true;
        UpdateChild(left_,new_value);
        left_=new_value;
     }
}

private:
Token op_;
public:
const Token & op(){
    return op_;
}


private:
Expr right_;
public:
const Expr & right(){
    return right_;
}


void right(Expr new_value){
     if(new_value != right_){
        is_modified_ = true;
        UpdateChild(right_,new_value);
        right_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(left()) || ::lox::IsModified(right());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,left());
::lox::UpdateSet(return_set,right());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(left());
::lox::ResetModify(right());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class GroupingExpr:public ExprBase
{
private:
explicit GroupingExpr(Expr expression_in)
:expression_(std::move(expression_in)){
UpdateChild(decltype(expression_)(),expression_);
}
friend AstNode;
public:

private:
Expr expression_;
public:
const Expr & expression(){
    return expression_;
}


void expression(Expr new_value){
     if(new_value != expression_){
        is_modified_ = true;
        UpdateChild(expression_,new_value);
        expression_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(expression());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,expression());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(expression());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class LiteralExpr:public ExprBase
{
private:
explicit LiteralExpr(Token value_in)
:value_(std::move(value_in)){

}
friend AstNode;
public:

private:
Token value_;
public:
const Token & value(){
    return value_;
}


bool IsModified() override{
    return is_modified_;
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ;
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class UnaryExpr:public ExprBase
{
private:
explicit UnaryExpr(Token op_in,Expr right_in)
:op_(std::move(op_in)),
right_(std::move(right_in)){
UpdateChild(decltype(right_)(),right_);
}
friend AstNode;
public:

private:
Token op_;
public:
const Token & op(){
    return op_;
}


private:
Expr right_;
public:
const Expr & right(){
    return right_;
}


void right(Expr new_value){
     if(new_value != right_){
        is_modified_ = true;
        UpdateChild(right_,new_value);
        right_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(right());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,right());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(right());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class CallExpr:public ExprBase
{
private:
explicit CallExpr(Expr callee_in,Token paren_in,std::vector<Expr> arguments_in)
:callee_(std::move(callee_in)),
paren_(std::move(paren_in)),
arguments_(std::move(arguments_in)){
UpdateChild(decltype(callee_)(),callee_);
UpdateChild(decltype(arguments_)(),arguments_);
}
friend AstNode;
public:

private:
Expr callee_;
public:
const Expr & callee(){
    return callee_;
}


void callee(Expr new_value){
     if(new_value != callee_){
        is_modified_ = true;
        UpdateChild(callee_,new_value);
        callee_=new_value;
     }
}

private:
Token paren_;
public:
const Token & paren(){
    return paren_;
}


private:
std::vector<Expr> arguments_;
public:
const std::vector<Expr> & arguments(){
    return arguments_;
}


void arguments(std::vector<Expr> new_value){
     if(new_value != arguments_){
        is_modified_ = true;
        UpdateChild(arguments_,new_value);
        arguments_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(callee()) || ::lox::IsModified(arguments());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,callee());
::lox::UpdateSet(return_set,arguments());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(callee());
::lox::ResetModify(arguments());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class GetAttrExpr:public ExprBase
{
private:
explicit GetAttrExpr(Expr src_object_in,Token attr_name_in)
:src_object_(std::move(src_object_in)),
attr_name_(std::move(attr_name_in)){
UpdateChild(decltype(src_object_)(),src_object_);
}
friend AstNode;
public:

private:
Expr src_object_;
public:
const Expr & src_object(){
    return src_object_;
}


void src_object(Expr new_value){
     if(new_value != src_object_){
        is_modified_ = true;
        UpdateChild(src_object_,new_value);
        src_object_=new_value;
     }
}

private:
Token attr_name_;
public:
const Token & attr_name(){
    return attr_name_;
}


bool IsModified() override{
    return is_modified_ || ::lox::IsModified(src_object());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,src_object());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(src_object());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class SetAttrExpr:public ExprBase
{
private:
explicit SetAttrExpr(Expr src_object_in,Token attr_name_in,Expr value_in)
:src_object_(std::move(src_object_in)),
attr_name_(std::move(attr_name_in)),
value_(std::move(value_in)){
UpdateChild(decltype(src_object_)(),src_object_);
UpdateChild(decltype(value_)(),value_);
}
friend AstNode;
public:

private:
Expr src_object_;
public:
const Expr & src_object(){
    return src_object_;
}


void src_object(Expr new_value){
     if(new_value != src_object_){
        is_modified_ = true;
        UpdateChild(src_object_,new_value);
        src_object_=new_value;
     }
}

private:
Token attr_name_;
public:
const Token & attr_name(){
    return attr_name_;
}


private:
Expr value_;
public:
const Expr & value(){
    return value_;
}


void value(Expr new_value){
     if(new_value != value_){
        is_modified_ = true;
        UpdateChild(value_,new_value);
        value_=new_value;
     }
}

bool IsModified() override{
    return is_modified_ || ::lox::IsModified(src_object()) || ::lox::IsModified(value());
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    ::lox::UpdateSet(return_set,src_object());
::lox::UpdateSet(return_set,value());
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ::lox::ResetModify(src_object());
::lox::ResetModify(value());
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};

class VariableExpr:public ExprBase
{
private:
explicit VariableExpr(Token name_in)
:name_(std::move(name_in)){

}
friend AstNode;
public:

private:
Token name_;
public:
const Token & name(){
    return name_;
}


bool IsModified() override{
    return is_modified_;
}

std::set<AstNode *>  Children() override{
    std::set<AstNode *> return_set;
    
    return return_set;
}
void ResetModify() override{
    is_modified_=false;
    ;
}
void Accept(IAstNodeVisitor * visitor) override {
  return visitor->Visit(this);
}
};


} // namespace lox
// clang-format on
